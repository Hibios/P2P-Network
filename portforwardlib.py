#!/usr/bin/python

# Утилита для переадресации портов на вашем маршрутизаторе с помощью UPnP
# - адаптирован для использования в командной строке
# - поддержка нескольких маршрутизаторов в локальной сети

import socket
import re

#Этот модуль разбивает URL на компоненты, по частям.
from urllib.parse import urlparse
import urllib.request, urllib.parse, urllib.error
from xml.dom.minidom import parseString
from xml.dom.minidom import Document
import http.client
import time
import sys

def discover():
    """
    Обнаружение маршрутизаторов с поддержкой UPNP в локальной сети. 
    Возвращает список URL-адресов с описаниями услуг.
    """
    SSDP_ADDR = "239.255.255.250"
    SSDP_PORT = 1900
    SSDP_MX = 2
    SSDP_ST = "urn:schemas-upnp-org:device:InternetGatewayDevice:1"

    WAIT = 1

    ssdpRequest = "M-SEARCH * HTTP/1.1\r\n" + \
                    "HOST: %s:%d\r\n" % (SSDP_ADDR, SSDP_PORT) + \
                    "MAN: \"ssdp:discover\"\r\n" + \
                    "MX: %d\r\n" % (SSDP_MX, ) + \
                    "ST: %s\r\n" % (SSDP_ST, ) + "\r\n"

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    #sock.setblocking(0)
    sock.sendto(ssdpRequest.encode(), (SSDP_ADDR, SSDP_PORT))
    time.sleep(WAIT)
    paths = []
    data = bytearray()
    while len(data) == 0:
        try:
            data, fromaddr = sock.recvfrom(1024)
            ip = fromaddr[0]
            #print("from ip: %s"%ip)
            parsed = re.findall(r'(?P<name>.*?): (?P<value>.*?)\r\n', str(data,'utf-8'))

            # получаем заголовок местоположения
            location = [x for x in parsed if x[0].lower() == "location"]

            # используем функцию urlparse, чтобы создать простой в использовании объект для хранения URL
            router_path = location[0][1]
            paths.append(router_path)

        except socket.error as e:
            print('''данных пока нет''')
            print(e)
            pass
        time.sleep(0.1)
    print(len(paths))
    print("Путь: {0}".format(paths))
    return paths


def get_wanip_path(upnp_url):
    # Получим файл профиля XML и запишем его в переменную
    directory = urllib.request.urlopen(upnp_url).read()

    # Создадим объект DOM, который представляет документ `directory`
    dom = parseString(directory)

    # Найти все 'serviceType' элементы
    service_types = dom.getElementsByTagName('serviceType')

    #  перебираем service_types, пока не получим WANIPConnection
    for service in service_types:
        if service.childNodes[0].data.find('WANIPConnection') > 0:
            path = service.parentNode.getElementsByTagName('controlURL')[0].childNodes[0].data
            return path

def open_port(service_url,external_port,internal_client,internal_port=None,protocol='TCP',duration=0,description=None,enabled=1):
    parsedurl = urlparse(service_url)

    if internal_port==None:
        internal_port = external_port

    if description == None:
        description = 'generated by port-forward.py'

    if not enabled:
        duration=1

    doc = Document()

    # создаём элемент конверта и устанавливаем его атрибуты
    envelope = doc.createElementNS('', 's:Envelope')
    envelope.setAttribute('xmlns:s', 'http://schemas.xmlsoap.org/soap/envelope/')
    envelope.setAttribute('s:encodingStyle', 'http://schemas.xmlsoap.org/soap/encoding/')

    # Создаём элемент тела
    body = doc.createElementNS('', 's:Body')

    # создаём элемент функции и устанавливаем его атрибут
    fn = doc.createElementNS('', 'u:AddPortMapping')
    fn.setAttribute('xmlns:u', 'urn:schemas-upnp-org:service:WANIPConnection:1')

    # настроим имена и значения элементов аргумента
    # используем список кортежей для сохранения порядка
    arguments = [
        ('NewRemoteHost', ""), # не используется - но требуется
        ('NewExternalPort', external_port),           # указать порт роутера
        ('NewProtocol', protocol),                 # указать протокол
        ('NewInternalPort', internal_port),           # указать порт на внутреннем хосте
        ('NewInternalClient', internal_client), # указать IP внутреннего хоста
        ('NewEnabled', enabled),                    # включить перенаправление
        ('NewPortMappingDescription', description), # добавить описание
        ('NewLeaseDuration', duration)]              # как долго это должно быть открыто?

    # контейнер для созданных узлов
    argument_list = []

    #перебирать аргументы, создавать узлы, создавать текстовые узлы,
    #добавляем текстовые узлы к узлам и, наконец, добавляем готовый продукт
    #в аргумент лист
    for k, v in arguments:
        v = str(v)
        tmp_node = doc.createElement(k)
        tmp_text_node = doc.createTextNode(v)
        tmp_node.appendChild(tmp_text_node)
        argument_list.append(tmp_node)

    # добавить подготовленные узлы аргумента к элементу функции
    for arg in argument_list:
        fn.appendChild(arg)

    # добавить элемент функции к элементу body
    body.appendChild(fn)

    # добавить элемент body к элементу envelope
    envelope.appendChild(body)

    # добавить элемент конверта в документ, сделав его корневым элементом
    doc.appendChild(envelope)

    # наше дерево готово, преобразовать его в строку
    pure_xml = doc.toxml()

    # используйте объект, возвращенный urlparse.urlparse, чтобы получить имя хоста и порт
    conn = http.client.HTTPConnection(parsedurl.hostname, parsedurl.port)

    #использовать путь WANIPConnection (или WANPPPConnection) для назначения этой службы,
    #вставить полезную нагрузку xml
    #добавить два заголовка, чтобы сообщить серверу, что именно мы отправляем.
    conn.request('POST',
        parsedurl.path,
        pure_xml,
        {'SOAPAction': '"urn:schemas-upnp-org:service:WANIPConnection:1#AddPortMapping"',
         'Content-Type': 'text/xml'}
    )

    # ждём ответа
    resp = conn.getresponse()

    return resp.status,resp.read()


def get_my_ip(routerip=None):
    if routerip==None:
        routerip="8.8.8.8"
    ret = None
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect((routerip,80))
        ret = s.getsockname()[0]
        s.close()
    except:
        pass
    return ret

def forwardPort(eport, iport, router, lanip, disable, protocol, time, description, verbose):
    """
    Функция перенаправления поров, работает по принципу: с начала если программа запускается
    впервые выполняется поиск нужных файлов роутера функцией discover(), а после второго запуска
    программа просто берёт когда-то уже взятые данные из файла route.txt.
    """
    if verbose:
        print("Обнаружение маршрутизаторов...")

    try:
        with open('route.txt') as f:
            lines = f.read()
            
            if len(lines) < 1:
                res = discover()
                with open('route.txt','wt') as f:
                    f.write(res[0])
                    print("Роутер найден! Данные записаны в файл route.txt(С 1 попытки).")
            else:
                res = [lines]
                print("Роутер найден! Данные взяты из файла route.txt.")
    except FileNotFoundError or EOFError:
        res = discover()
        with open('route.txt','wt') as f:
            f.write(res[0])
        print("Роутер найден! Данные записаны в файл route.txt(Со 2 попытки).")

    allok = True
    for path in res:
        discparsed = urlparse(path)
        service_path = get_wanip_path(path)
        service_url = "%s://%s%s"%(discparsed.scheme,discparsed.netloc,service_path)
        routerip = discparsed.netloc.split(':')[0]
        if router !=None and routerip not in router:
            continue

        localip = lanip
        if lanip == None:
            localip = get_my_ip(routerip)

        enabled = int(not disable)

        dis=''
        if not enabled:
            dis='disable of '

        status,message = open_port(service_url,eport,internal_client=localip,internal_port=iport,protocol=protocol,duration=time,description=description,enabled = enabled)
        if status==200:

            if verbose:
                print(("%sПорт перенаправлен: %s успешно, %s -> %s:%s"%(dis,routerip, eport,localip,iport)))
        else:
            sys.stderr.write("%sПеренаправление на %s произошло с ошибкой, статус=%s сообщение=%s\n"%(dis,routerip,status,message))
            allok = False


    return allok